Je vais préparer une synthèse détaillée avec des visuels sur la séquence d'amorçage de Linux. Cela inclura :

- Une explication détaillée du processus de démarrage
- Comment passer des arguments au boot (ponctuellement et de manière permanente)
- La reconstruction du boot
- L'analyse des temps de démarrage
- Des travaux pratiques avec explications (démarrage, mode rescue, mode emergency, mode débogage, réinitialisation du mot de passe root)

J'intégrerai des schémas et des captures d'écran pour rendre les explications plus claires. Je te tiendrai informé dès que ce sera prêt.

# 1. Fonctionnement détaillé du boot Linux

Le processus de démarrage d’une distribution Linux s’effectue en plusieurs **étapes successives**, depuis la mise sous tension jusqu’à l’apparition du login. Voici le déroulement **pas à pas** :

1. **Initialisation BIOS/UEFI** – Dès l’allumage, le firmware de la carte mère (BIOS sur les systèmes anciens, UEFI sur les récents) prend le contrôle du CPU. Il exécute le **POST** (*Power-On Self Test*) pour tester la RAM et le matériel de base. Ensuite, le firmware recherche un périphérique **bootable** selon l’ordre de démarrage configuré (disque, clé USB, réseau, etc.). Il charge en mémoire le secteur de boot du périphérique choisi (Master Boot Record ou équivalent UEFI) puis lui transfère le contrôle ([An introduction to the Linux boot and startup processes with GPT and GRUB2 – Both.org](https://www.both.org/?p=4597#:~:text=POST%20checks%20the%C2%A0basic%20operability%20of,MBR)). En mode BIOS/MBR, ce secteur d’amorçage (512 octets) contient un **bootloader primaire** minimal qui localise la suite du programme de boot sur le disque.

2. **Chargeur d’amorçage (GRUB)** – Le système charge alors le véritable chargeur d’amorçage, typiquement **GRUB2** (Grand Unified Bootloader). GRUB s’affiche avant le lancement de l’OS, permettant éventuellement de choisir entre plusieurs noyaux ou systèmes. Son rôle principal est de **trouver et charger le noyau Linux** en mémoire (fichier `vmlinuz`) ainsi que l’initramfs associé ([An introduction to the Linux boot and startup processes with GPT and GRUB2 – Both.org](https://www.both.org/?p=4597#:~:text=The%20primary%20function%20of%20the,loaded%20into%20memory%20and%20running)) ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,it%20passes%20CONTROL%20to%20it)). GRUB comprend les systèmes de fichiers courants, ce qui lui permet de lire le noyau et l’initramfs directement depuis la partition `/boot`. Une fois le noyau (et l’initramfs) chargés en RAM, GRUB lui cède la main ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,it%20passes%20CONTROL%20to%20it)).

3. **Noyau Linux** – Le noyau Linux démarre avec les privilèges du *Ring*0 (mode superviseur). Il exécute sa routine d’initialisation : décompression (le noyau est un fichier compressé auto-extractible), configuration de la mémoire, détection et initialisation des pilotes de matériel (CPU, mémoire, périphériques) ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,init%20script%20from%20the%20initramfs)). À ce stade apparaissent les premiers messages du noyau (affichés sur la console). Si un **initramfs** (Initial RAM Filesystem) a été chargé, le noyau le met en place : il crée un système de fichiers temporaire en RAM (tmpfs), y décompresse l’archive initramfs, puis **exécute le programme `/init`** présent dans cet initramfs ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,after)). Cet espace utilisateur initial en RAM permet d’effectuer des tâches indispensables que le noyau seul ne peut gérer (par ex. déchiffrer un disque chiffré, charger des modules nécessaires au montage du disque système, activer du RAID logiciel, etc.) ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,after)). Une fois ces préparatifs faits, l’initramfs va *basculer* (par `switch_root`) vers le véritable système de fichiers racine du disque et y transférer le contrôle au processus d’init principal.

4. **Init/Systemd et services** – Le processus init (PID 1) du système prend le relais. Sur les distributions modernes, il s’agit de **systemd**. Systemd démarre très tôt (juste après le noyau) et monte les systèmes de fichiers listés dans `/etc/fstab` (y compris la racine, si ce n’est déjà fait, les partitions *swap*, etc.) ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,up%20is%20successful)). Ensuite, systemd lance en parallèle tous les services et unités nécessaires pour atteindre la **cible par défaut** (target *default*, souvent alias de `graphical.target` pour un poste de travail, ou `multi-user.target` pour un serveur) ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,up%20is%20successful)). Cela inclut l’activation des périphériques, du réseau, puis des démons et services de fond (impression, base de données, serveur web, interface graphique…). Une fois la cible atteinte, le système est **démarré** et opérationnel, prêt à afficher l’invite de connexion (mode texte ou graphique).

 ([Understanding the (Embedded) Linux boot process - Klein Embedded](https://kleinembedded.com/understanding-the-embedded-linux-boot-process/)) *Schéma simplifié du processus de boot Linux en mode BIOS (à gauche) et UEFI (à droite), depuis le firmware jusqu’au démarrage de l’OS (noyau puis espace user avec le système d’init).*  

# 2. Passage d’arguments au boot (niveaux de secours)

Il est possible de modifier le démarrage de Linux en passant des **paramètres au noyau** afin d’influencer le niveau de démarrage ou activer certains modes spéciaux de maintenance. On utilise pour cela des arguments sur la ligne de commande du noyau (kernel command line). Les plus courants pour dépanner sont :

- **`single`**, **`1`** ou **`runlevel1`** (alias de `systemd.unit=rescue.target`) – Démarrage en mode **rescue (monoutilisateur)**. Ce mode correspond à l’ancien *runlevel 1* (single-user) des systèmes SysV. Le système démarre avec un ensemble minimal de services : les systèmes de fichiers sont montés et une session root est ouverte en mode texte, mais **aucun service réseau ni multi-utilisateur n’est lancé** ([ emergency vs rescue systemd targets](https://forums.fedoraforum.org/showthread.php?270936-emergency-vs-rescue-systemd-targets#:~:text=%3E%20%3E%20In%20systemd%2C%20,)) ([An introduction to the Linux boot and startup processes with GPT and GRUB2 – Both.org](https://www.both.org/?p=4597#:~:text=S%20emergency,shell%20on%20the%20main%20console)). Par sécurité, le mot de passe root est généralement requis pour ouvrir la session en console dans ce mode ([Working With the GRUB 2 Bootloader and Configuring Boot Services](https://docs.oracle.com/en/operating-systems/oracle-linux/7/osmanage/osmanage-WorkingWiththeGRUB2BootloaderandConfiguringBootServices.html#:~:text=,target)).

- **`emergency`** ou **`-b`** (alias `systemd.unit=emergency.target`) – Démarrage en mode **urgence**. C’est un niveau encore plus minimal que *single*. Seul le strict nécessaire est lancé : le noyau monte la racine en lecture seule et ouvre un shell root **sans monter les autres systèmes de fichiers** ([ emergency vs rescue systemd targets](https://forums.fedoraforum.org/showthread.php?270936-emergency-vs-rescue-systemd-targets#:~:text=%3E%20%3E%20In%20systemd%2C%20,)). Aucun service n’est démarré automatiquement ([ emergency vs rescue systemd targets](https://forums.fedoraforum.org/showthread.php?270936-emergency-vs-rescue-systemd-targets#:~:text=%3E%20%3E%20In%20systemd%2C%20,)). Ce mode équivaut à passer `init=/bin/sh` (shell directement en PID1) et sert aux cas où même le mode rescue pourrait poser problème. Là aussi, un mot de passe root est demandé pour accéder au shell ([Working With the GRUB 2 Bootloader and Configuring Boot Services](https://docs.oracle.com/en/operating-systems/oracle-linux/7/osmanage/osmanage-WorkingWiththeGRUB2BootloaderandConfiguringBootServices.html#:~:text=%60)).

- *(Autres paramètres utiles :* **`quiet`** pour masquer les messages noyau, **`noplymouth`** pour désactiver l’animation graphique de boot, **`systemd.unit=rescue.target`** ou **`=emergency.target`** qui sont équivalents aux alias ci-dessus, etc.*)*

## Passage ponctuel via GRUB

Pour tester un de ces modes **ponctuellement**, sans modifier la configuration de boot, on peut utiliser l’éditeur interactif de GRUB. Au menu GRUB, sélectionnez l’entrée de votre distribution puis appuyez sur la touche **`e`** (*edit*) avant le démarrage. Vous accédez alors aux lignes de configuration de cette entrée. Repérez la ligne commençant par `linux` qui contient déjà des paramètres (comme `ro quiet splash`). Ajoutez-y l’argument souhaité – par exemple `single` ou `systemd.unit=rescue.target` – puis démarrez en appuyant sur **Ctrl+X** (ou F10). 

 ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/)) *Écran du menu GRUB (GNU GRUB v2) permettant d’éditer les options du noyau avant boot. Ici, il faut presser `e` pour accéder à l’édition.*  

Une fois en mode édition, vous pouvez naviguer avec les flèches. Par exemple, pour passer en **mode rescue**, modifiez la ligne Linux en remplaçant `ro quiet splash` par `rw single` (ou ajoutez `systemd.unit=rescue.target`). Le fait de passer la racine en `rw` (lecture-écriture) est souvent nécessaire pour pouvoir effectuer des modifications en mode maintenance. 

 ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/)) *Exemple d’édition de la ligne du noyau dans GRUB pour démarrer en mode single-user (argument `single` ajouté). Ici sur Ubuntu, cela correspond à `systemd.unit=rescue.target`.*  

Après avoir ajouté l’argument, on lance le boot modifié via **Ctrl+X**. Le système va démarrer dans le mode demandé pour cette session uniquement. 

> **À noter :** D’autres arguments de dépannage existent. Par ex, `init=/bin/bash` (voir section 5) donne un shell très tôt (avant systemd). Sur les distributions Red Hat, on trouve aussi le **mode rescue initramfs** (option `rd.break`) qui interrompt le démarrage dans initramfs pour effectuer des réparations avant même de monter la racine.

## Configuration permanente via `/etc/default/grub`

Si l’on souhaite que **certaines options de démarrage soient permanentes** (par ex. toujours démarrer en mode texte multi-utilisateur plutôt qu’en graphique, ou désactiver `quiet` pour voir les logs), on doit modifier la configuration de GRUB. La plupart des distributions utilisent le fichier **`/etc/default/grub`**. On y trouve une variable `GRUB_CMDLINE_LINUX_DEFAULT` (ou `GRUB_CMDLINE_LINUX`) contenant les arguments du noyau par défaut. On peut y ajouter nos paramètres. Par exemple, pour que le système démarre toujours en mode texte multi-user (runlevel 3), on peut ajouter `systemd.unit=multi-user.target` dans cette variable. Une fois le fichier édité et sauvegardé, il faut **regénérer le fichier de configuration** GRUB :

```bash
sudo update-grub    # sur Debian/Ubuntu (alias de grub-mkconfig)
``` 

Cette commande va analyser les noyaux disponibles et recréer le fichier `/boot/grub/grub.cfg` en y incluant la nouvelle ligne de commande du noyau ([Working With the GRUB 2 Bootloader and Configuring Boot Services](https://docs.oracle.com/en/operating-systems/oracle-linux/7/osmanage/osmanage-WorkingWiththeGRUB2BootloaderandConfiguringBootServices.html#:~:text=The%20%60grub2,configuration%20file)) ([Working With the GRUB 2 Bootloader and Configuring Boot Services](https://docs.oracle.com/en/operating-systems/oracle-linux/7/osmanage/osmanage-WorkingWiththeGRUB2BootloaderandConfiguringBootServices.html#:~:text=To%20set%20the%20UEK%20as,the%20default%20boot%20kernel)). On peut vérifier dans `/boot/grub/grub.cfg` que notre paramètre apparaît bien dans la section correspondant au noyau par défaut. Un redémarrage permettra de tester la prise en compte de ces modifications.

# 3. Reconstruction du boot (GRUB, initramfs…)

Lorsque le système ne démarre plus correctement, ou après certaines modifications (mise à jour de noyau, changement de matériel…), il peut être nécessaire de **reconstruire la configuration de boot**. Les opérations courantes incluent :

- **Regénérer la configuration GRUB** – Si de nouveaux noyaux ont été installés ou si on a modifié `/etc/default/grub`, on doit recréer le fichier de configuration de GRUB. La commande standard est `grub-mkconfig -o /boot/grub/grub.cfg` (ou son alias `update-grub` sur Ubuntu/Debian). Cette commande détecte les OS présents et met à jour le menu. Par exemple, son exécution affiche les noyaux trouvés : *“Found linux image: /boot/vmlinuz-… Found initrd image: /boot/initrd.img-…”*, éventuellement les autres OS (Windows…) et génère le fichier final ([[SOLVED] GRUB not listening to its config file / Installation / Arch Linux Forums](https://bbs.archlinux.org/viewtopic.php?id=271791#:~:text=sudo%20update,on%20them%20and%20create%20new)). On obtient un message “**done**” si tout s’est bien passé ([[SOLVED] GRUB not listening to its config file / Installation / Arch Linux Forums](https://bbs.archlinux.org/viewtopic.php?id=271791#:~:text=boot%20entries,done)).  

- **Recréer une image initramfs** – L’**initramfs** (initial RAM disk) contient les scripts et modules nécessaires au démarrage (montage des volumes, etc.). Si cette image est manquante, corrompue, ou si on a modifié des modules critiques (pilotes de stockage, chiffrement…), il faut la régénérer. Sur Debian/Ubuntu, on utilise l’outil **`update-initramfs`** (ou bas niveau `mkinitramfs`). Par exemple, `sudo update-initramfs -c -k $(uname -r)` permet de **créer un nouvel initrd** pour la version de noyau en cours ([software installation - What does "regenerate your initramfs" mean? - Ask Ubuntu](https://askubuntu.com/questions/1351911/what-does-regenerate-your-initramfs-mean#:~:text=The%20proper%20command%20would%20be%3A)) (`-c` pour create, `-k` pour spécifier la version). Sur les distributions RedHat (Fedora, CentOS…), l’équivalent est **`dracut`** : par ex. `sudo dracut -f` reconstruit l’initramfs par défaut (option `-f` = force overwrite). Après régénération, on vérifie que le fichier `/boot/initramfs-<version>.img` a été mis à jour (date du jour) et on peut redémarrer.

- **Réparation du bootloader ou de /boot** – En cas de problème plus grave (fichiers manquants, partition */boot* corrompue), il faut intervenir en mode dépannage. Si GRUB lui-même est endommagé (ex: message *grub rescue>*), il peut être nécessaire de *réinstaller le bootloader* dans le MBR/ESP. Pour cela, on démarre depuis un support live (Live USB), on monte la partition système et on utilise `grub-install`. Par exemple : 
  ```bash
  sudo mount /dev/sda1 /mnt   # monter la racine
  sudo mount --bind /dev /mnt/dev && sudo chroot /mnt   # entrer dans le système
  grub-install /dev/sda       # réinstaller le MBR sur sda
  grub-mkconfig -o /boot/grub/grub.cfg   # régénérer la config
  exit
  ``` 
  Ceci réécrit le programme GRUB sur le disque et recrée son fichier de config. Si c’est la partition `/boot` elle-même qui a un problème (système de fichiers corrompu par ex.), on devra possiblement lancer une réparation (`fsck`) ou restaurer les fichiers noyau/initrd depuis une sauvegarde ou en réinstallant le paquet noyau. Après toute intervention, on peut utiliser les commandes précédentes pour s’assurer que GRUB et l’initramfs sont cohérents avec le système avant de tenter un reboot.

> 🔧 *Astuce : l’outil graphique **Boot-Repair** (sous Ubuntu) peut automatiser certaines de ces réparations (réinstallation de GRUB, etc.), mais il est important de comprendre les étapes manuelles ci-dessus pour intervenir sur tout système Linux.*

# 4. Analyse des temps de démarrage

Lorsqu’un Linux est fonctionnel, il est souvent utile d’**analyser le temps de boot** afin de l’optimiser. L’init systemd fournit pour cela la commande **`systemd-analyze`**. 

- **Durée totale de démarrage** – Sans argument, `systemd-analyze` affiche le temps écoulé dans chaque phase : firmware, bootloader, noyau, initrd et espace utilisateur. Par exemple :  
  ```bash
  $ systemd-analyze  
  Startup finished in 53.921s (firmware) + 2.643s (loader) + 2.236s (kernel) + 4.348s (initrd) + 10.082s (userspace) = 1min 13.233s 
  ```  
  *Ici, le BIOS a pris un temps anormalement long (54s), puis GRUB ~2.6s, le noyau ~2.2s, l’initramfs ~4.3s, et enfin l’espace utilisateur (démarrage de tous les services) ~10s, pour un total d’environ 73 ([Analyze Linux startup performance | Opensource.com](https://opensource.com/article/20/9/systemd-startup-configuration#:~:text=%5Broot%40david%20~%5D%24%20systemd,root%40david))】.* Ce résumé permet de repérer si l’essentiel du temps se passe **avant** le noyau (firmware/bootloader) – ce qu’on ne peut pas toujours optimiser facilement – ou **après**, c’est-à-dire au chargement du système lui-même.

- **Chronologie des services (blame)** – La commande `systemd-analyze blame` liste tous les services démarrés lors du boot, triés par durée décroissant ([Analyze Linux startup performance | Opensource.com](https://opensource.com/article/20/9/systemd-startup-configuration#:~:text=You%20can%20use%20%60systemd,initialize%2C%20from%20most%20to%20least))】. Cela met en évidence les **unités les plus longues à initialiser**. Par exemple, un service réseau qui attend une connexion peut allonger sensiblement le démarrage. La sortie ressemble à :  
  ```bash
  $ systemd-analyze blame  
           5.417s NetworkManager-wait-online.service  
           3.423s dracut-initqueue.service  
           2.715s systemd-udev-settle.service  
           1.275s udisks2.service  
            996ms upower.service  
            637ms lvm2-monitor.service  
            ... (liste complète) ...
  ```  
  Ici `NetworkManager-wait-online.service` a pris 5,4 secondes – ce type de service peut souvent être **désactivé** si non requis, gagnant ainsi du temps au démarrag ([Analyze Linux startup performance | Opensource.com](https://opensource.com/article/20/9/systemd-startup-configuration#:~:text=The%20data%20from%20this%20command,for%20each%20boot%20and%20startup))】. Attention à l’interprétation : de nombreux services s’exécutent **en parallèle**, le total de ces durées additionnées dépasse donc largement le temps réel du boo ([Analyze Linux startup performance | Opensource.com](https://opensource.com/article/20/9/systemd-startup-configuration#:~:text=Because%20many%20of%20these%20services,find%20any%20significant%20savings%20here))】. L’ordre donne néanmoins des pistes sur **quels services optimiser ou désactiver** pour réduire le temps de boot.

- **Chaîne critique et diagramme** – Systemd permet également de visualiser la séquence sous forme de dépendances temporelles. La commande `systemd-analyze critical-chain` affiche la suite des unités critiques sur le chemin du target final (chemin critique qui a déterminé la durée du boot). Chaque unité y est affichée avec son temps de démarrage et son lien de dépendance avec la suivante. Pour une vue plus complète, `systemd-analyze plot > boot.svg` génère un **diagramme SVG** du déroulement du boot, montrant chaque service sur une ligne chronologique. En ouvrant ce fichier SVG, on obtient un **graphique type “Gantt”** du démarrage où l’on visualise clairement quels services ont tourné en parallèle et pendant combien de temps. Ce schéma permet d’identifier par exemple des **goulets d’étranglement** (une unité bloquante qui en retarde d’autres). On peut ainsi agir précisément (par ex. en retardant un service non critique, en changeant un service de type *synchronous* à *simple* pour qu’il n’attende pas, etc.).

**Optimisation du boot :** Sur la base de ces analyses, on peut gagner du temps de démarrage en **désactivant les services inutiles** (par ex., sur un poste sans réseau local, désactiver `NetworkManager-wait-online` évite d’attendre une connexion ([Analyze Linux startup performance | Opensource.com](https://opensource.com/article/20/9/systemd-startup-configuration#:~:text=The%20data%20from%20this%20command,for%20each%20boot%20and%20startup))】. On peut aussi réduire le temps du BIOS/UEFI en activant un *fast boot* si disponible, ou en ajustant des réglages (désactiver la recherche de périphériques inexistants qui rallonge le POST). L’utilisation d’un SSD à la place d’un HDD améliore aussi considérablement le chargement des fichiers système. Enfin, veiller à avoir un initramfs dépouillé du superflu (certaines distributions intègrent par défaut de nombreux modules génériques) peut grappiller quelques secondes. L’outil **`systemd-analyze`** fournit donc une base objective pour mesurer l’impact de chaque modification sur le temps de démarrage.

# 5. Exemples pratiques de modes de démarrage (captures et explications)

Dans cette section, nous illustrons différents modes de démarrage et cas d’usage, avec les commandes et retours associés.

- **Démarrage standard et logs (journalctl)** – Lors d’un boot normal, systemd enregistre tous les messages dans le journal binaire. On peut les consulter une fois connecté avec `journalctl -b` (logs du boot courant) ou `journalctl -b -1` (boot précédent, etc.). Par exemple, le début du log peut montrer les messages du kernel, de systemd et des services initiaux :  
  ```  
  -- Logs begin at Tue 2023-07-18 10:15:32 UTC, end at Tue 2023-07-18 10:16:20 UTC. --  
  Jul 18 10:15:32 host systemd-journald[101]: Runtime journal is using 8.0M (max allowed 50.0M).  
  Jul 18 10:15:32 host kernel: Linux version 5.15.0-46-generic (buildd@lpgase) ...  
  Jul 18 10:15:32 host kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-46-generic root=UUID=... ro quiet splash  
  Jul 18 10:15:32 host kernel: Kernel modules linked in: crc32c_intel sd_mod t10_pi crct10dif_pclmul ...  
  Jul 18 10:15:32 host systemd[1]: Finished Create Volatile Files and Directories.  
  Jul 18 10:15:32 host systemd[1]: Started Journal Service.  
  Jul 18 10:15:32 host systemd[1]: Reached target Login Prompts.  
  ...  
  ```  
  *(Exemple fictif de sortie abrégée.)* On y voit la ligne de commande du noyau, la liste des modules, puis les unités systemd qui s’initialisent. Ces journaux sont précieux pour diagnostiquer un problème de démarrage a posteriori. Par exemple, une erreur de montage de disque ou d’unit systemd échouée apparaîtra en rouge (avec `journalctl -p err -b` on filtre les erreurs du boot). On peut aussi accéder à ces logs en **temps réel pendant le boot** en appuyant sur <kbd>Esc</kbd> (sur Ubuntu par exemple, pour quitter le splash screen graphique) ou en enlevant `quiet` des paramètres de noyau.

- **Mode *Rescue*** – Pour entrer en mode **rescue** (monoutilisateur avec support minimal), on peut soit ajouter l’argument `single`/`1` dans GRUB comme vu en section 2, soit sélectionner l’entrée dédiée si la distribution la propose. Par exemple, sur Debian/Ubuntu, le menu “Advanced options” de GRUB contient souvent une entrée “Recovery mode” équivalente. Une fois le boot lancé avec `systemd.unit=rescue.target`, le système monte la racine et passe en mode monoutilisateur. **Il demande généralement le mot de passe administrateur** sur la console avant de donner accès. On obtient alors un shell root en mode texte. Seuls quelques services de base sont actifs (journal, filesystems montés). Cela permet d’inspecter et réparer le système. Par exemple, on peut vérifier l’état des disques (`fsck`), désactiver un service problématique (`systemctl disable <service>`), ou rétablir un fichier de configuration. Pour sortir du mode rescue et poursuivre un démarrage normal, on peut soit taper `Ctrl+D` (ce qui continue vers la cible par défaut), soit exécuter explicitement `systemctl default`. 

- **Mode *Emergency*** – Pour des cas plus critiques, le mode **emergency** fournit un shell ultra-minimal. On l’atteint via l’argument `systemd.unit=emergency.target` (ou `emergency`/`-b`). Contrairement au rescue, **aucun système de fichier n’est monté en lecture-écriture**, et presque aucun service n’est lanc ([ emergency vs rescue systemd targets](https://forums.fedoraforum.org/showthread.php?270936-emergency-vs-rescue-systemd-targets#:~:text=%3E%20%3E%20In%20systemd%2C%20,))】. Après le mot de passe root, on obtient un shell sur la racine montée en lecture seule. Il faut souvent d’abord remonter la racine en RW manuellement (`mount -o remount,rw /`) pour effectuer des changements. Ce mode sert par exemple à corriger un fstab erroné qui empêcherait le montage normal – on peut éditer `/etc/fstab` depuis ce shell, puis taper `systemctl default` pour reprendre la suite du boot normal. Emergency target équivaut en fait au fameux **`init=/bin/bash`**, mais en utilisant quand même systemd en arrière-plan pour pouvoir ensuite relancer le processus normal une fois l’urgence résolu ([ emergency vs rescue systemd targets](https://forums.fedoraforum.org/showthread.php?270936-emergency-vs-rescue-systemd-targets#:~:text=%3E%20%3E%20In%20systemd%2C%20,))】.

- **Mode débogage (init=/bin/bash)** – On peut demander au noyau de lancer un programme différent à la place de l’`init` PID1. Par exemple, passer **`init=/bin/bash`** dans la ligne de commande du noyau va directement nous donner un shell *root* très tôt, **sans passer par systemd**. C’est similaire au mode emergency, mais encore plus brut. Le shell s’ouvre avant même le montage des disques (à part la racine généralement montée en lecture seule par le noyau). On s’en sert pour des **interventions de dernière chance**, quand même systemd ne passe pas. Concrètement, après édition de GRUB pour ajouter `init=/bin/bash` (et `rw` si on veut directement écrire), le système boot et vous voilà en ligne de commande *bash#*. À ce stade, vous pouvez corriger des fichiers, charger des modules manuellement (`modprobe`), etc. N’oubliez pas de monter en RW si nécessaire (`mount -o remount,rw /`). Une fois les corrections effectuées, vous pouvez soit exécuter manuellement la suite du processus (`exec /sbin/init` pour lancer systemd depuis ce shell), soit redémarrer (`reboot -f`). Ce mode n’est pas persistant (c’est un paramètre noyau temporaire).

- **Réinitialisation du mot de passe root via GRUB** – Un cas d’école : vous avez perdu le mot de passe root et ne pouvez plus administrer votre machine. La procédure classique consiste à utiliser les modes ci-dessus. Par exemple, depuis GRUB, éditez la ligne du noyau et ajoutez `init=/bin/bash` (ou `single` sur des systèmes où le root n’est pas protégé en single-user). Assurez-vous que la racine est montée en lecture-écriture (`rw`). Démarrez ; vous obtenez un shell root sans demande de mot de passe. Vous pouvez alors utiliser la commande `passwd root` pour définir un nouveau mot de passe root. Il faudra également exécuter `sync` pour forcer l’écriture sur le disque, puis redémarrer (commande `reboot`). Après cela, le nouveau mot de passe root est acti ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/#:~:text=4,Enter%20the%20following%20command)) ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/#:~:text=6,Enter%20the%20following%20command))】. Cette méthode est illustrée ci-dessous :

  - *Accéder à l’édition GRUB et ajouter l’option init=/bin/bash :* (voir captures de la section 2 ci-dessus, identiques à cette procédure).  
  - *Une fois dans le shell root de secours :*  
    ```bash
    mount -o remount,rw /        # passer la racine en écriture  
    passwd root                  # réinitialiser le mot de passe root  
    sync && reboot -f  
    ```  
    ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/#:~:text=4,Enter%20the%20following%20command)) ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/#:~:text=6,Enter%20the%20following%20command))】  
    Si tout se passe bien, `passwd` annonce "*password updated successfully*". On redémarre alors normalement le système et l’on peut se connecter avec le nouveau mot de passe.  

Ces différents modes de démarrage offrent chacun un niveau d’intervention spécifique. En cas de souci, commencez par le mode *rescue* pour les problèmes légers (désactivation de service, etc.). Passez en *emergency* ou avec `init=/bin/bash` pour les cas où la situation du système de fichiers ou du bootloader nécessite des actions manuelles approfondies. Grâce aux captures et exemples ci-dessus, on voit concrètement comment accéder à ces modes et les commandes essentielles à y utiliser pour restaurer un système Linux fonctionnel.

