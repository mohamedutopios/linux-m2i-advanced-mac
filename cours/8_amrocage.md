Je vais pr√©parer une synth√®se d√©taill√©e avec des visuels sur la s√©quence d'amor√ßage de Linux. Cela inclura :

- Une explication d√©taill√©e du processus de d√©marrage
- Comment passer des arguments au boot (ponctuellement et de mani√®re permanente)
- La reconstruction du boot
- L'analyse des temps de d√©marrage
- Des travaux pratiques avec explications (d√©marrage, mode rescue, mode emergency, mode d√©bogage, r√©initialisation du mot de passe root)

J'int√©grerai des sch√©mas et des captures d'√©cran pour rendre les explications plus claires. Je te tiendrai inform√© d√®s que ce sera pr√™t.

# 1. Fonctionnement d√©taill√© du boot Linux

Le processus de d√©marrage d‚Äôune distribution Linux s‚Äôeffectue en plusieurs **√©tapes successives**, depuis la mise sous tension jusqu‚Äô√† l‚Äôapparition du login. Voici le d√©roulement **pas √† pas**¬†:

1. **Initialisation BIOS/UEFI** ‚Äì D√®s l‚Äôallumage, le firmware de la carte m√®re (BIOS sur les syst√®mes anciens, UEFI sur les r√©cents) prend le contr√¥le du CPU. Il ex√©cute le **POST** (*Power-On Self Test*) pour tester la RAM et le mat√©riel de base. Ensuite, le firmware recherche un p√©riph√©rique **bootable** selon l‚Äôordre de d√©marrage configur√© (disque, cl√© USB, r√©seau, etc.). Il charge en m√©moire le secteur de boot du p√©riph√©rique choisi (Master Boot Record ou √©quivalent UEFI) puis lui transf√®re le contr√¥le ([An introduction to the Linux boot and startup processes with GPT and GRUB2 ‚Äì Both.org](https://www.both.org/?p=4597#:~:text=POST%20checks%20the%C2%A0basic%20operability%20of,MBR)). En mode BIOS/MBR, ce secteur d‚Äôamor√ßage (512 octets) contient un **bootloader primaire** minimal qui localise la suite du programme de boot sur le disque.

2. **Chargeur d‚Äôamor√ßage (GRUB)** ‚Äì Le syst√®me charge alors le v√©ritable chargeur d‚Äôamor√ßage, typiquement **GRUB2** (Grand Unified Bootloader). GRUB s‚Äôaffiche avant le lancement de l‚ÄôOS, permettant √©ventuellement de choisir entre plusieurs noyaux ou syst√®mes. Son r√¥le principal est de **trouver et charger le noyau Linux** en m√©moire (fichier `vmlinuz`) ainsi que l‚Äôinitramfs associ√© ([An introduction to the Linux boot and startup processes with GPT and GRUB2 ‚Äì Both.org](https://www.both.org/?p=4597#:~:text=The%20primary%20function%20of%20the,loaded%20into%20memory%20and%20running)) ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,it%20passes%20CONTROL%20to%20it)). GRUB comprend les syst√®mes de fichiers courants, ce qui lui permet de lire le noyau et l‚Äôinitramfs directement depuis la partition `/boot`. Une fois le noyau (et l‚Äôinitramfs) charg√©s en RAM, GRUB lui c√®de la main ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,it%20passes%20CONTROL%20to%20it)).

3. **Noyau Linux** ‚Äì Le noyau Linux d√©marre avec les privil√®ges du *Ring*0 (mode superviseur). Il ex√©cute sa routine d‚Äôinitialisation : d√©compression (le noyau est un fichier compress√© auto-extractible), configuration de la m√©moire, d√©tection et initialisation des pilotes de mat√©riel (CPU, m√©moire, p√©riph√©riques) ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,init%20script%20from%20the%20initramfs)). √Ä ce stade apparaissent les premiers messages du noyau (affich√©s sur la console). Si un **initramfs** (Initial RAM Filesystem) a √©t√© charg√©, le noyau le met en place¬†: il cr√©e un syst√®me de fichiers temporaire en RAM (tmpfs), y d√©compresse l‚Äôarchive initramfs, puis **ex√©cute le programme `/init`** pr√©sent dans cet initramfs ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,after)). Cet espace utilisateur initial en RAM permet d‚Äôeffectuer des t√¢ches indispensables que le noyau seul ne peut g√©rer (par ex. d√©chiffrer un disque chiffr√©, charger des modules n√©cessaires au montage du disque syst√®me, activer du RAID logiciel, etc.) ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,after)). Une fois ces pr√©paratifs faits, l‚Äôinitramfs va *basculer* (par `switch_root`) vers le v√©ritable syst√®me de fichiers racine du disque et y transf√©rer le contr√¥le au processus d‚Äôinit principal.

4. **Init/Systemd et services** ‚Äì Le processus init (PID 1) du syst√®me prend le relais. Sur les distributions modernes, il s‚Äôagit de **systemd**. Systemd d√©marre tr√®s t√¥t (juste apr√®s le noyau) et monte les syst√®mes de fichiers list√©s dans `/etc/fstab` (y compris la racine, si ce n‚Äôest d√©j√† fait, les partitions *swap*, etc.) ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,up%20is%20successful)). Ensuite, systemd lance en parall√®le tous les services et unit√©s n√©cessaires pour atteindre la **cible par d√©faut** (target *default*, souvent alias de `graphical.target` pour un poste de travail, ou `multi-user.target` pour un serveur) ([Linux OS bootup sequence with systemd | Linux.org](https://www.linux.org/threads/linux-os-bootup-sequence-with-systemd.46385/#:~:text=%2A%20,up%20is%20successful)). Cela inclut l‚Äôactivation des p√©riph√©riques, du r√©seau, puis des d√©mons et services de fond (impression, base de donn√©es, serveur web, interface graphique‚Ä¶). Une fois la cible atteinte, le syst√®me est **d√©marr√©** et op√©rationnel, pr√™t √† afficher l‚Äôinvite de connexion (mode texte ou graphique).

 ([Understanding the (Embedded) Linux boot process - Klein Embedded](https://kleinembedded.com/understanding-the-embedded-linux-boot-process/)) *Sch√©ma simplifi√© du processus de boot Linux en mode BIOS (√† gauche) et UEFI (√† droite), depuis le firmware jusqu‚Äôau d√©marrage de l‚ÄôOS (noyau puis espace user avec le syst√®me d‚Äôinit).*  

# 2. Passage d‚Äôarguments au boot (niveaux de secours)

Il est possible de modifier le d√©marrage de Linux en passant des **param√®tres au noyau** afin d‚Äôinfluencer le niveau de d√©marrage ou activer certains modes sp√©ciaux de maintenance. On utilise pour cela des arguments sur la ligne de commande du noyau (kernel command line). Les plus courants pour d√©panner sont¬†:

- **`single`**, **`1`** ou **`runlevel1`** (alias de `systemd.unit=rescue.target`) ‚Äì D√©marrage en mode **rescue (monoutilisateur)**. Ce mode correspond √† l‚Äôancien *runlevel 1* (single-user) des syst√®mes SysV. Le syst√®me d√©marre avec un ensemble minimal de services : les syst√®mes de fichiers sont mont√©s et une session root est ouverte en mode texte, mais **aucun service r√©seau ni multi-utilisateur n‚Äôest lanc√©** ([ emergency vs rescue systemd targets](https://forums.fedoraforum.org/showthread.php?270936-emergency-vs-rescue-systemd-targets#:~:text=%3E%20%3E%20In%20systemd%2C%20,)) ([An introduction to the Linux boot and startup processes with GPT and GRUB2 ‚Äì Both.org](https://www.both.org/?p=4597#:~:text=S%20emergency,shell%20on%20the%20main%20console)). Par s√©curit√©, le mot de passe root est g√©n√©ralement requis pour ouvrir la session en console dans ce mode ([Working With the GRUB 2 Bootloader and Configuring Boot Services](https://docs.oracle.com/en/operating-systems/oracle-linux/7/osmanage/osmanage-WorkingWiththeGRUB2BootloaderandConfiguringBootServices.html#:~:text=,target)).

- **`emergency`** ou **`-b`** (alias `systemd.unit=emergency.target`) ‚Äì D√©marrage en mode **urgence**. C‚Äôest un niveau encore plus minimal que *single*. Seul le strict n√©cessaire est lanc√© : le noyau monte la racine en lecture seule et ouvre un shell root **sans monter les autres syst√®mes de fichiers** ([ emergency vs rescue systemd targets](https://forums.fedoraforum.org/showthread.php?270936-emergency-vs-rescue-systemd-targets#:~:text=%3E%20%3E%20In%20systemd%2C%20,)). Aucun service n‚Äôest d√©marr√© automatiquement ([ emergency vs rescue systemd targets](https://forums.fedoraforum.org/showthread.php?270936-emergency-vs-rescue-systemd-targets#:~:text=%3E%20%3E%20In%20systemd%2C%20,)). Ce mode √©quivaut √† passer `init=/bin/sh` (shell directement en PID1) et sert aux cas o√π m√™me le mode rescue pourrait poser probl√®me. L√† aussi, un mot de passe root est demand√© pour acc√©der au shell ([Working With the GRUB 2 Bootloader and Configuring Boot Services](https://docs.oracle.com/en/operating-systems/oracle-linux/7/osmanage/osmanage-WorkingWiththeGRUB2BootloaderandConfiguringBootServices.html#:~:text=%60)).

- *(Autres param√®tres utiles :* **`quiet`** pour masquer les messages noyau, **`noplymouth`** pour d√©sactiver l‚Äôanimation graphique de boot, **`systemd.unit=rescue.target`** ou **`=emergency.target`** qui sont √©quivalents aux alias ci-dessus, etc.*)*

## Passage ponctuel via GRUB

Pour tester un de ces modes **ponctuellement**, sans modifier la configuration de boot, on peut utiliser l‚Äô√©diteur interactif de GRUB. Au menu GRUB, s√©lectionnez l‚Äôentr√©e de votre distribution puis appuyez sur la touche **`e`** (*edit*) avant le d√©marrage. Vous acc√©dez alors aux lignes de configuration de cette entr√©e. Rep√©rez la ligne commen√ßant par `linux` qui contient d√©j√† des param√®tres (comme `ro quiet splash`). Ajoutez-y l‚Äôargument souhait√© ‚Äì par exemple `single` ou `systemd.unit=rescue.target` ‚Äì puis d√©marrez en appuyant sur **Ctrl+X** (ou F10). 

 ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/)) *√âcran du menu GRUB (GNU GRUB v2) permettant d‚Äô√©diter les options du noyau avant boot. Ici, il faut presser `e` pour acc√©der √† l‚Äô√©dition.*  

Une fois en mode √©dition, vous pouvez naviguer avec les fl√®ches. Par exemple, pour passer en **mode rescue**, modifiez la ligne Linux en rempla√ßant `ro quiet splash` par `rw single` (ou ajoutez `systemd.unit=rescue.target`). Le fait de passer la racine en `rw` (lecture-√©criture) est souvent n√©cessaire pour pouvoir effectuer des modifications en mode maintenance. 

 ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/)) *Exemple d‚Äô√©dition de la ligne du noyau dans GRUB pour d√©marrer en mode single-user (argument `single` ajout√©). Ici sur Ubuntu, cela correspond √† `systemd.unit=rescue.target`.*  

Apr√®s avoir ajout√© l‚Äôargument, on lance le boot modifi√© via **Ctrl+X**. Le syst√®me va d√©marrer dans le mode demand√© pour cette session uniquement. 

> **√Ä noter :** D‚Äôautres arguments de d√©pannage existent. Par ex, `init=/bin/bash` (voir section 5) donne un shell tr√®s t√¥t (avant systemd). Sur les distributions Red Hat, on trouve aussi le **mode rescue initramfs** (option `rd.break`) qui interrompt le d√©marrage dans initramfs pour effectuer des r√©parations avant m√™me de monter la racine.

## Configuration permanente via `/etc/default/grub`

Si l‚Äôon souhaite que **certaines options de d√©marrage soient permanentes** (par ex. toujours d√©marrer en mode texte multi-utilisateur plut√¥t qu‚Äôen graphique, ou d√©sactiver `quiet` pour voir les logs), on doit modifier la configuration de GRUB. La plupart des distributions utilisent le fichier **`/etc/default/grub`**. On y trouve une variable `GRUB_CMDLINE_LINUX_DEFAULT` (ou `GRUB_CMDLINE_LINUX`) contenant les arguments du noyau par d√©faut. On peut y ajouter nos param√®tres. Par exemple, pour que le syst√®me d√©marre toujours en mode texte multi-user (runlevel 3), on peut ajouter `systemd.unit=multi-user.target` dans cette variable. Une fois le fichier √©dit√© et sauvegard√©, il faut **reg√©n√©rer le fichier de configuration** GRUB :

```bash
sudo update-grub    # sur Debian/Ubuntu (alias de grub-mkconfig)
``` 

Cette commande va analyser les noyaux disponibles et recr√©er le fichier `/boot/grub/grub.cfg` en y incluant la nouvelle ligne de commande du noyau ([Working With the GRUB 2 Bootloader and Configuring Boot Services](https://docs.oracle.com/en/operating-systems/oracle-linux/7/osmanage/osmanage-WorkingWiththeGRUB2BootloaderandConfiguringBootServices.html#:~:text=The%20%60grub2,configuration%20file)) ([Working With the GRUB 2 Bootloader and Configuring Boot Services](https://docs.oracle.com/en/operating-systems/oracle-linux/7/osmanage/osmanage-WorkingWiththeGRUB2BootloaderandConfiguringBootServices.html#:~:text=To%20set%20the%20UEK%20as,the%20default%20boot%20kernel)). On peut v√©rifier dans `/boot/grub/grub.cfg` que notre param√®tre appara√Æt bien dans la section correspondant au noyau par d√©faut. Un red√©marrage permettra de tester la prise en compte de ces modifications.

# 3. Reconstruction du boot (GRUB, initramfs‚Ä¶)

Lorsque le syst√®me ne d√©marre plus correctement, ou apr√®s certaines modifications (mise √† jour de noyau, changement de mat√©riel‚Ä¶), il peut √™tre n√©cessaire de **reconstruire la configuration de boot**. Les op√©rations courantes incluent :

- **Reg√©n√©rer la configuration GRUB** ‚Äì Si de nouveaux noyaux ont √©t√© install√©s ou si on a modifi√© `/etc/default/grub`, on doit recr√©er le fichier de configuration de GRUB. La commande standard est `grub-mkconfig -o /boot/grub/grub.cfg` (ou son alias `update-grub` sur Ubuntu/Debian). Cette commande d√©tecte les OS pr√©sents et met √† jour le menu. Par exemple, son ex√©cution affiche les noyaux trouv√©s : *‚ÄúFound linux image: /boot/vmlinuz-‚Ä¶¬†Found initrd image: /boot/initrd.img-‚Ä¶‚Äù*, √©ventuellement les autres OS (Windows‚Ä¶) et g√©n√®re le fichier final ([[SOLVED] GRUB not listening to its config file / Installation / Arch Linux Forums](https://bbs.archlinux.org/viewtopic.php?id=271791#:~:text=sudo%20update,on%20them%20and%20create%20new)). On obtient un message ‚Äú**done**‚Äù si tout s‚Äôest bien pass√© ([[SOLVED] GRUB not listening to its config file / Installation / Arch Linux Forums](https://bbs.archlinux.org/viewtopic.php?id=271791#:~:text=boot%20entries,done)).  

- **Recr√©er une image initramfs** ‚Äì L‚Äô**initramfs** (initial RAM disk) contient les scripts et modules n√©cessaires au d√©marrage (montage des volumes, etc.). Si cette image est manquante, corrompue, ou si on a modifi√© des modules critiques (pilotes de stockage, chiffrement‚Ä¶), il faut la r√©g√©n√©rer. Sur Debian/Ubuntu, on utilise l‚Äôoutil **`update-initramfs`** (ou bas niveau `mkinitramfs`). Par exemple, `sudo update-initramfs -c -k $(uname -r)` permet de **cr√©er un nouvel initrd** pour la version de noyau en cours ([software installation - What does "regenerate your initramfs" mean? - Ask Ubuntu](https://askubuntu.com/questions/1351911/what-does-regenerate-your-initramfs-mean#:~:text=The%20proper%20command%20would%20be%3A)) (`-c` pour create, `-k` pour sp√©cifier la version). Sur les distributions RedHat (Fedora, CentOS‚Ä¶), l‚Äô√©quivalent est **`dracut`**¬†: par ex. `sudo dracut -f` reconstruit l‚Äôinitramfs par d√©faut (option `-f` = force overwrite). Apr√®s r√©g√©n√©ration, on v√©rifie que le fichier `/boot/initramfs-<version>.img` a √©t√© mis √† jour (date du jour) et on peut red√©marrer.

- **R√©paration du bootloader ou de /boot** ‚Äì En cas de probl√®me plus grave (fichiers manquants, partition */boot* corrompue), il faut intervenir en mode d√©pannage. Si GRUB lui-m√™me est endommag√© (ex: message *grub rescue>*), il peut √™tre n√©cessaire de *r√©installer le bootloader* dans le MBR/ESP. Pour cela, on d√©marre depuis un support live (Live USB), on monte la partition syst√®me et on utilise `grub-install`. Par exemple¬†: 
  ```bash
  sudo mount /dev/sda1 /mnt   # monter la racine
  sudo mount --bind /dev /mnt/dev && sudo chroot /mnt   # entrer dans le syst√®me
  grub-install /dev/sda       # r√©installer le MBR sur sda
  grub-mkconfig -o /boot/grub/grub.cfg   # r√©g√©n√©rer la config
  exit
  ``` 
  Ceci r√©√©crit le programme GRUB sur le disque et recr√©e son fichier de config. Si c‚Äôest la partition `/boot` elle-m√™me qui a un probl√®me (syst√®me de fichiers corrompu par ex.), on devra possiblement lancer une r√©paration (`fsck`) ou restaurer les fichiers noyau/initrd depuis une sauvegarde ou en r√©installant le paquet noyau. Apr√®s toute intervention, on peut utiliser les commandes pr√©c√©dentes pour s‚Äôassurer que GRUB et l‚Äôinitramfs sont coh√©rents avec le syst√®me avant de tenter un reboot.

> üîß *Astuce : l‚Äôoutil graphique **Boot-Repair** (sous Ubuntu) peut automatiser certaines de ces r√©parations (r√©installation de GRUB, etc.), mais il est important de comprendre les √©tapes manuelles ci-dessus pour intervenir sur tout syst√®me Linux.*

# 4. Analyse des temps de d√©marrage

Lorsqu‚Äôun Linux est fonctionnel, il est souvent utile d‚Äô**analyser le temps de boot** afin de l‚Äôoptimiser. L‚Äôinit systemd fournit pour cela la commande **`systemd-analyze`**. 

- **Dur√©e totale de d√©marrage** ‚Äì Sans argument, `systemd-analyze` affiche le temps √©coul√© dans chaque phase : firmware, bootloader, noyau, initrd et espace utilisateur. Par exemple¬†:  
  ```bash
  $ systemd-analyze  
  Startup finished in 53.921s (firmware) + 2.643s (loader) + 2.236s (kernel) + 4.348s (initrd) + 10.082s (userspace) = 1min 13.233s 
  ```  
  *Ici, le BIOS a pris un temps anormalement long (54s), puis GRUB ~2.6s, le noyau ~2.2s, l‚Äôinitramfs ~4.3s, et enfin l‚Äôespace utilisateur (d√©marrage de tous les services) ~10s, pour un total d‚Äôenviron 73 ([Analyze Linux startup performance | Opensource.com](https://opensource.com/article/20/9/systemd-startup-configuration#:~:text=%5Broot%40david%20~%5D%24%20systemd,root%40david))„Äë.* Ce r√©sum√© permet de rep√©rer si l‚Äôessentiel du temps se passe **avant** le noyau (firmware/bootloader) ‚Äì ce qu‚Äôon ne peut pas toujours optimiser facilement ‚Äì ou **apr√®s**, c‚Äôest-√†-dire au chargement du syst√®me lui-m√™me.

- **Chronologie des services (blame)** ‚Äì La commande `systemd-analyze blame` liste tous les services d√©marr√©s lors du boot, tri√©s par dur√©e d√©croissant ([Analyze Linux startup performance | Opensource.com](https://opensource.com/article/20/9/systemd-startup-configuration#:~:text=You%20can%20use%20%60systemd,initialize%2C%20from%20most%20to%20least))„Äë. Cela met en √©vidence les **unit√©s les plus longues √† initialiser**. Par exemple, un service r√©seau qui attend une connexion peut allonger sensiblement le d√©marrage. La sortie ressemble √†¬†:  
  ```bash
  $ systemd-analyze blame  
           5.417s NetworkManager-wait-online.service  
           3.423s dracut-initqueue.service  
           2.715s systemd-udev-settle.service  
           1.275s udisks2.service  
            996ms upower.service  
            637ms lvm2-monitor.service  
            ... (liste compl√®te) ...
  ```  
  Ici `NetworkManager-wait-online.service` a pris 5,4 secondes ‚Äì ce type de service peut souvent √™tre **d√©sactiv√©** si non requis, gagnant ainsi du temps au d√©marrag ([Analyze Linux startup performance | Opensource.com](https://opensource.com/article/20/9/systemd-startup-configuration#:~:text=The%20data%20from%20this%20command,for%20each%20boot%20and%20startup))„Äë. Attention √† l‚Äôinterpr√©tation¬†: de nombreux services s‚Äôex√©cutent **en parall√®le**, le total de ces dur√©es additionn√©es d√©passe donc largement le temps r√©el du boo ([Analyze Linux startup performance | Opensource.com](https://opensource.com/article/20/9/systemd-startup-configuration#:~:text=Because%20many%20of%20these%20services,find%20any%20significant%20savings%20here))„Äë. L‚Äôordre donne n√©anmoins des pistes sur **quels services optimiser ou d√©sactiver** pour r√©duire le temps de boot.

- **Cha√Æne critique et diagramme** ‚Äì Systemd permet √©galement de visualiser la s√©quence sous forme de d√©pendances temporelles. La commande `systemd-analyze critical-chain` affiche la suite des unit√©s critiques sur le chemin du target final (chemin critique qui a d√©termin√© la dur√©e du boot). Chaque unit√© y est affich√©e avec son temps de d√©marrage et son lien de d√©pendance avec la suivante. Pour une vue plus compl√®te, `systemd-analyze plot > boot.svg` g√©n√®re un **diagramme SVG** du d√©roulement du boot, montrant chaque service sur une ligne chronologique. En ouvrant ce fichier SVG, on obtient un **graphique type ‚ÄúGantt‚Äù** du d√©marrage o√π l‚Äôon visualise clairement quels services ont tourn√© en parall√®le et pendant combien de temps. Ce sch√©ma permet d‚Äôidentifier par exemple des **goulets d‚Äô√©tranglement** (une unit√© bloquante qui en retarde d‚Äôautres). On peut ainsi agir pr√©cis√©ment (par ex. en retardant un service non critique, en changeant un service de type *synchronous* √† *simple* pour qu‚Äôil n‚Äôattende pas, etc.).

**Optimisation du boot¬†:** Sur la base de ces analyses, on peut gagner du temps de d√©marrage en **d√©sactivant les services inutiles** (par ex., sur un poste sans r√©seau local, d√©sactiver `NetworkManager-wait-online` √©vite d‚Äôattendre une connexion ([Analyze Linux startup performance | Opensource.com](https://opensource.com/article/20/9/systemd-startup-configuration#:~:text=The%20data%20from%20this%20command,for%20each%20boot%20and%20startup))„Äë. On peut aussi r√©duire le temps du BIOS/UEFI en activant un *fast boot* si disponible, ou en ajustant des r√©glages (d√©sactiver la recherche de p√©riph√©riques inexistants qui rallonge le POST). L‚Äôutilisation d‚Äôun SSD √† la place d‚Äôun HDD am√©liore aussi consid√©rablement le chargement des fichiers syst√®me. Enfin, veiller √† avoir un initramfs d√©pouill√© du superflu (certaines distributions int√®grent par d√©faut de nombreux modules g√©n√©riques) peut grappiller quelques secondes. L‚Äôoutil **`systemd-analyze`** fournit donc une base objective pour mesurer l‚Äôimpact de chaque modification sur le temps de d√©marrage.

# 5. Exemples pratiques de modes de d√©marrage (captures et explications)

Dans cette section, nous illustrons diff√©rents modes de d√©marrage et cas d‚Äôusage, avec les commandes et retours associ√©s.

- **D√©marrage standard et logs (journalctl)** ‚Äì Lors d‚Äôun boot normal, systemd enregistre tous les messages dans le journal binaire. On peut les consulter une fois connect√© avec `journalctl -b` (logs du boot courant) ou `journalctl -b -1` (boot pr√©c√©dent, etc.). Par exemple, le d√©but du log peut montrer les messages du kernel, de systemd et des services initiaux¬†:  
  ```  
  -- Logs begin at Tue 2023-07-18 10:15:32 UTC, end at Tue 2023-07-18 10:16:20 UTC. --  
  Jul 18 10:15:32 host systemd-journald[101]: Runtime journal is using 8.0M (max allowed 50.0M).  
  Jul 18 10:15:32 host kernel: Linux version 5.15.0-46-generic (buildd@lpgase) ...  
  Jul 18 10:15:32 host kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.15.0-46-generic root=UUID=... ro quiet splash  
  Jul 18 10:15:32 host kernel: Kernel modules linked in: crc32c_intel sd_mod t10_pi crct10dif_pclmul ...  
  Jul 18 10:15:32 host systemd[1]: Finished Create Volatile Files and Directories.  
  Jul 18 10:15:32 host systemd[1]: Started Journal Service.  
  Jul 18 10:15:32 host systemd[1]: Reached target Login Prompts.  
  ...  
  ```  
  *(Exemple fictif de sortie abr√©g√©e.)* On y voit la ligne de commande du noyau, la liste des modules, puis les unit√©s systemd qui s‚Äôinitialisent. Ces journaux sont pr√©cieux pour diagnostiquer un probl√®me de d√©marrage a posteriori. Par exemple, une erreur de montage de disque ou d‚Äôunit systemd √©chou√©e appara√Ætra en rouge (avec `journalctl -p err -b` on filtre les erreurs du boot). On peut aussi acc√©der √† ces logs en **temps r√©el pendant le boot** en appuyant sur <kbd>Esc</kbd> (sur Ubuntu par exemple, pour quitter le splash screen graphique) ou en enlevant `quiet` des param√®tres de noyau.

- **Mode *Rescue*** ‚Äì Pour entrer en mode **rescue** (monoutilisateur avec support minimal), on peut soit ajouter l‚Äôargument `single`/`1` dans GRUB comme vu en section 2, soit s√©lectionner l‚Äôentr√©e d√©di√©e si la distribution la propose. Par exemple, sur Debian/Ubuntu, le menu ‚ÄúAdvanced options‚Äù de GRUB contient souvent une entr√©e ‚ÄúRecovery mode‚Äù √©quivalente. Une fois le boot lanc√© avec `systemd.unit=rescue.target`, le syst√®me monte la racine et passe en mode monoutilisateur. **Il demande g√©n√©ralement le mot de passe administrateur** sur la console avant de donner acc√®s. On obtient alors un shell root en mode texte. Seuls quelques services de base sont actifs (journal, filesystems mont√©s). Cela permet d‚Äôinspecter et r√©parer le syst√®me. Par exemple, on peut v√©rifier l‚Äô√©tat des disques (`fsck`), d√©sactiver un service probl√©matique (`systemctl disable <service>`), ou r√©tablir un fichier de configuration. Pour sortir du mode rescue et poursuivre un d√©marrage normal, on peut soit taper `Ctrl+D` (ce qui continue vers la cible par d√©faut), soit ex√©cuter explicitement `systemctl default`. 

- **Mode *Emergency*** ‚Äì Pour des cas plus critiques, le mode **emergency** fournit un shell ultra-minimal. On l‚Äôatteint via l‚Äôargument `systemd.unit=emergency.target` (ou `emergency`/`-b`). Contrairement au rescue, **aucun syst√®me de fichier n‚Äôest mont√© en lecture-√©criture**, et presque aucun service n‚Äôest lanc ([ emergency vs rescue systemd targets](https://forums.fedoraforum.org/showthread.php?270936-emergency-vs-rescue-systemd-targets#:~:text=%3E%20%3E%20In%20systemd%2C%20,))„Äë. Apr√®s le mot de passe root, on obtient un shell sur la racine mont√©e en lecture seule. Il faut souvent d‚Äôabord remonter la racine en RW manuellement (`mount -o remount,rw /`) pour effectuer des changements. Ce mode sert par exemple √† corriger un fstab erron√© qui emp√™cherait le montage normal ‚Äì on peut √©diter `/etc/fstab` depuis ce shell, puis taper `systemctl default` pour reprendre la suite du boot normal. Emergency target √©quivaut en fait au fameux **`init=/bin/bash`**, mais en utilisant quand m√™me systemd en arri√®re-plan pour pouvoir ensuite relancer le processus normal une fois l‚Äôurgence r√©solu ([ emergency vs rescue systemd targets](https://forums.fedoraforum.org/showthread.php?270936-emergency-vs-rescue-systemd-targets#:~:text=%3E%20%3E%20In%20systemd%2C%20,))„Äë.

- **Mode d√©bogage (init=/bin/bash)** ‚Äì On peut demander au noyau de lancer un programme diff√©rent √† la place de l‚Äô`init` PID1. Par exemple, passer **`init=/bin/bash`** dans la ligne de commande du noyau va directement nous donner un shell *root* tr√®s t√¥t, **sans passer par systemd**. C‚Äôest similaire au mode emergency, mais encore plus brut. Le shell s‚Äôouvre avant m√™me le montage des disques (√† part la racine g√©n√©ralement mont√©e en lecture seule par le noyau). On s‚Äôen sert pour des **interventions de derni√®re chance**, quand m√™me systemd ne passe pas. Concr√®tement, apr√®s √©dition de GRUB pour ajouter `init=/bin/bash` (et `rw` si on veut directement √©crire), le syst√®me boot et vous voil√† en ligne de commande *bash#*. √Ä ce stade, vous pouvez corriger des fichiers, charger des modules manuellement (`modprobe`), etc. N‚Äôoubliez pas de monter en RW si n√©cessaire (`mount -o remount,rw /`). Une fois les corrections effectu√©es, vous pouvez soit ex√©cuter manuellement la suite du processus (`exec /sbin/init` pour lancer systemd depuis ce shell), soit red√©marrer (`reboot -f`). Ce mode n‚Äôest pas persistant (c‚Äôest un param√®tre noyau temporaire).

- **R√©initialisation du mot de passe root via GRUB** ‚Äì Un cas d‚Äô√©cole : vous avez perdu le mot de passe root et ne pouvez plus administrer votre machine. La proc√©dure classique consiste √† utiliser les modes ci-dessus. Par exemple, depuis GRUB, √©ditez la ligne du noyau et ajoutez `init=/bin/bash` (ou `single` sur des syst√®mes o√π le root n‚Äôest pas prot√©g√© en single-user). Assurez-vous que la racine est mont√©e en lecture-√©criture (`rw`). D√©marrez ; vous obtenez un shell root sans demande de mot de passe. Vous pouvez alors utiliser la commande `passwd root` pour d√©finir un nouveau mot de passe root. Il faudra √©galement ex√©cuter `sync` pour forcer l‚Äô√©criture sur le disque, puis red√©marrer (commande `reboot`). Apr√®s cela, le nouveau mot de passe root est acti ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/#:~:text=4,Enter%20the%20following%20command)) ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/#:~:text=6,Enter%20the%20following%20command))„Äë. Cette m√©thode est illustr√©e ci-dessous¬†:

  - *Acc√©der √† l‚Äô√©dition GRUB et ajouter l‚Äôoption init=/bin/bash :* (voir captures de la section 2 ci-dessus, identiques √† cette proc√©dure).  
  - *Une fois dans le shell root de secours :*  
    ```bash
    mount -o remount,rw /        # passer la racine en √©criture  
    passwd root                  # r√©initialiser le mot de passe root  
    sync && reboot -f  
    ```  
    ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/#:~:text=4,Enter%20the%20following%20command)) ([How to Reset Password in Linux | Step-by-step Guide](https://gcore.com/learning/how-to-reset-password-in-linux/#:~:text=6,Enter%20the%20following%20command))„Äë  
    Si tout se passe bien, `passwd` annonce "*password updated successfully*". On red√©marre alors normalement le syst√®me et l‚Äôon peut se connecter avec le nouveau mot de passe.  

Ces diff√©rents modes de d√©marrage offrent chacun un niveau d‚Äôintervention sp√©cifique. En cas de souci, commencez par le mode *rescue* pour les probl√®mes l√©gers (d√©sactivation de service, etc.). Passez en *emergency* ou avec `init=/bin/bash` pour les cas o√π la situation du syst√®me de fichiers ou du bootloader n√©cessite des actions manuelles approfondies. Gr√¢ce aux captures et exemples ci-dessus, on voit concr√®tement comment acc√©der √† ces modes et les commandes essentielles √† y utiliser pour restaurer un syst√®me Linux fonctionnel.

